<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Oxyzen Digital | Keynote Master Architect v1.1.1</title>
    <style>
        :root {
            --ui-font: "Segoe UI", Tahoma, sans-serif;
            --active-blue: #0078d4;
            --header-dark: #3a3a3a;
            --audit-success: #2e7d32;
            --caution-orange: #ef6c00;
            
            --bg-app: #cfd8dc;
            --bg-panel: #ffffff;
            --bg-header: #3c3e3f;
            --bg-browser: #eceff1;
            --bg-row: #ffffff;
            --text-main: #000000;
            --border-color: #ccc;
            --border-light: #f0f0f0;
        }

        [data-theme="dark"] {
            --bg-app: #202124;
            --bg-panel: #2d2e31;
            --bg-header: #3c4043;
            --bg-browser: #35363a;
            --bg-row: #2d2e31;
            --text-main: #e8eaed;
            --border-color: #5f6368;
            --border-light: #3c4043;
            --header-dark: #000000;
        }

        body, html { height: 100%; margin: 0; font-family: var(--ui-font); font-size: 13px; overflow: hidden; background: var(--bg-app); color: var(--text-main); }
        .app-wrapper { display: flex; flex-direction: column; height: 100vh; }
        
        .toolbar {
            background: var(--bg-panel); border-bottom: 1px solid var(--border-color); padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center; z-index: 100; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .pane-container { display: flex; flex: 1; overflow: hidden; justify-content: center; align-items: stretch; padding: 10px; gap: 0; }
        
        .pane { display: flex; flex-direction: column; background: var(--bg-panel); overflow: hidden; position: relative; border: 1px solid #999; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .pane.primary { flex: 0 0 50%; z-index: 10; border-radius: 4px; min-width: 450px; }
        .pane.secondary { flex: 1; min-width: 250px; border-radius: 4px; margin: 0 5px; }

        .resizer { width: 10px; cursor: col-resize; background: transparent; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .resizer:hover { background: rgba(0,120,212,0.2); }
        .resizer::after { content: 'â‹®'; color: #666; font-weight: bold; }

        .pane-header { background: var(--bg-header); border-bottom: 1px solid var(--border-color); padding: 10px; font-weight: 600; }
        .editor-layout { display: flex; flex: 1; overflow: hidden; }
        
        .section-browser { width: 150px; background: var(--bg-browser); border-right: 1px solid var(--border-color); overflow-y: auto; font-size: 10px; padding: 5px; flex-shrink: 0; }
        .browser-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 5px; border-bottom: 1px solid var(--border-color); margin-bottom: 8px; }
        
        .caution-box { 
            background: #fff3e0; border: 1px solid var(--caution-orange); color: var(--caution-orange);
            padding: 5px; border-radius: 3px; font-size: 9px; margin-top: 5px; cursor: pointer; text-align: center; font-weight: bold;
        }
        .caution-box.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        
        .header-icon { font-size: 14px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s; user-select: none; }
        .header-icon:hover { opacity: 1; }
        .header-icon.disabled { opacity: 0.3; cursor: not-allowed; }
        .icon-red { color: #d32f2f; }
        .icon-blue { color: var(--active-blue); }

        .keynote-scroll { flex: 1; overflow-y: auto; scroll-behavior: smooth; padding-bottom: 50vh; }
        .tree-node { display: flex; flex-direction: column; }
        .row { display: flex; padding: 5px 10px; align-items: center; cursor: grab; background: var(--bg-row); border-bottom: 1px solid var(--border-light); border-left: 5px solid transparent; transition: border-left-color 0.3s, opacity 0.3s; }
        .row.is-root { background: var(--header-dark) !important; color: #fff; font-weight: bold; position: sticky; top: 0; z-index: 5; }
        
        .row.audit-match {
            opacity: 0.5;
            border-left-color: var(--audit-success);
        }
        .row.audit-match:hover {
            opacity: 1;
        }
        
        .row.selected-highlight {
            background-color: rgba(255, 0, 0, 0.15);
            border-left-color: #d32f2f !important;
            opacity: 1 !important;
        }

        .row.is-root.selected-highlight {
            /* Keep dark background for readability, add border/shadow for selection visibility */
            box-shadow: inset 0 0 0 1px #d32f2f;
        }
        
        .row.drop-inside { background: rgba(0, 120, 212, 0.25) !important; outline: 2px dashed var(--active-blue); }
        .row.drop-above { border-top: 3px solid var(--caution-orange); background: linear-gradient(to bottom, rgba(239, 108, 0, 0.2), transparent); }
        .row.drop-below { border-bottom: 3px solid var(--caution-orange); background: linear-gradient(to top, rgba(239, 108, 0, 0.2), transparent); }
        .row.drop-merge { 
            background: repeating-linear-gradient(45deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.1) 10px, rgba(76, 175, 80, 0.2) 10px, rgba(76, 175, 80, 0.2) 20px) !important; 
            outline: 2px dashed #2e7d32; 
            border-color: #2e7d32 !important; 
        }

        .lvl-container { display: flex; flex-direction: column; padding-left: 12px; border-left: 1px solid var(--border-light); margin-left: 4px; }
        .toggle { width: 15px; cursor: pointer; font-size: 9px; display: inline-block; transition: transform 0.2s; user-select: none; }
        .collapsed > .row > .toggle { transform: rotate(-90deg); }
        .collapsed > .lvl-container { display: none; }

        .key-num-input { font-weight: bold; width: 110px; border: 1px solid transparent; background: transparent; color: inherit; outline: none; }
        .key-desc-input { flex-grow: 1; border: 1px solid transparent; background: transparent; color: inherit; outline: none; padding: 2px 5px; }
        .key-num-input:focus, .key-desc-input:focus { background: var(--bg-row); border-color: var(--active-blue); color: var(--text-main); box-shadow: 0 0 3px rgba(0,0,0,0.2); }

        .btn { border: none; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 11px; }
        .btn:disabled { background: #ccc !important; opacity: 0.6; cursor: not-allowed; }
        .btn-save { background: #2e7d32; color: white; width: 100%; margin-top: 5px; }
        
        .action-tools { opacity: 0; margin-left: 10px; display: flex; gap: 4px; }
        .row:hover .action-tools { opacity: 1; }
        .tool-btn { cursor: pointer; font-size: 10px; padding: 2px 5px; border-radius: 3px; border: 1px solid var(--border-color); background: var(--bg-panel); color: inherit; }
        
        .hidden { display: none !important; }

        /* Custom Tooltip */
        #tooltip {
            position: fixed;
            background: var(--bg-header);
            color: var(--text-main);
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            z-index: 9999;
            transition: opacity 0.15s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 300px;
        }

        /* Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; justify-content: center; align-items: center; }
        .modal-content { background: var(--bg-panel); padding: 20px; border-radius: 4px; border: 1px solid var(--border-color); width: 300px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 11px; opacity: 0.8; }
        .input-group input { width: 100%; padding: 5px; background: var(--bg-row); border: 1px solid var(--border-color); color: var(--text-main); outline: none; box-sizing: border-box; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }

        /* File Info Box */
        .file-info-box {
            background: var(--active-blue);
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .file-name { font-weight: bold; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; }
        .locate-btn { cursor: pointer; margin-left: 8px; font-size: 14px; opacity: 0.9; line-height: 1; }
        .locate-btn:hover { opacity: 1; transform: scale(1.1); }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--header-dark);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
            pointer-events: none;
        }
        .toast.show { opacity: 1; bottom: 40px; }
    </style>
</head>
<body>

<div class="app-wrapper">
    <div id="tooltip"></div>
    <div id="toast-notification" class="toast"></div>
    <div class="toolbar">
        <div style="font-weight: bold;">OXYZEN DIGITAL | ARCHITECT <span style="font-size:10px; opacity:0.5; margin-left:5px;">v1.1.1</span></div>
        <input type="text" id="globalSearch" placeholder="Deep Search Numbers or Content..." onkeyup="ViewModel.search(this.value)" style="width:400px; padding:8px; border:1px solid var(--border-color); background:var(--bg-panel); color:var(--text-main); border-radius:20px; outline:none;">
        <div>
            <button id="undoBtn" class="btn" style="background:transparent; border:1px solid var(--border-color); color:var(--text-main); margin-right:10px; opacity:0.5;" disabled onclick="AppState.undo()" title="Undo last action">â†¶ Undo</button>
            <button class="btn" style="background:transparent; border:1px solid var(--border-color); color:var(--text-main); margin-right:10px;" onclick="ViewModel.openFindReplace()" title="Find and Replace text in descriptions">Find & Replace</button>
            <button class="btn" style="background:transparent; border:1px solid var(--border-color); color:var(--text-main); margin-right:10px;" onclick="ViewModel.openChangeCase()" title="Change text case (Upper, Lower, Title, Sentence)">Aa Case</button>
            <button class="btn" style="background:transparent; border:1px solid var(--border-color); color:var(--text-main); margin-right:10px;" onclick="AppState.toggleDarkMode()" title="Toggle Light/Dark Theme">ðŸŒ— Theme</button>
            <button class="btn" style="background:#546e7a; color:white;" onclick="ViewModel.addPane()" title="Add a secondary pane for file comparison">+ COMPARISON</button>
            <button id="auditBtn" class="btn" style="background:var(--active-blue); color:white;" disabled onclick="ViewModel.runAudit()" title="Highlight rows with matching descriptions across panes">RUN COORDINATION AUDIT</button>
        </div>
    </div>
    <div class="pane-container" id="paneBox"></div>
    
    <div id="findReplaceModal" class="modal hidden">
        <div class="modal-content">
            <h3 style="margin-top:0; margin-bottom:15px;">Find & Replace</h3>
            <div class="input-group">
                <label>Find:</label>
                <input type="text" id="findInput" placeholder="Text to find...">
            </div>
            <div class="input-group">
                <label>Replace with:</label>
                <input type="text" id="replaceInput" placeholder="Replacement text...">
            </div>
            <div class="modal-actions">
                <button class="btn" style="background:transparent; border:1px solid var(--border-color); color:var(--text-main);" onclick="ViewModel.closeFindReplace()">Cancel</button>
                <button class="btn btn-save" style="width:auto;" onclick="ViewModel.executeReplace()">Replace All</button>
            </div>
        </div>
    </div>

    <div id="changeCaseModal" class="modal hidden">
        <div class="modal-content">
            <h3 style="margin-top:0; margin-bottom:15px;">Change Text Case</h3>
            <div class="input-group">
                <label>Scope:</label>
                <select id="caseScope" style="width:100%; padding:5px; background:var(--bg-row); color:var(--text-main); border:1px solid var(--border-color);">
                    <option value="global">Entire File</option>
                    <option value="selected">Selected Section & Children</option>
                </select>
            </div>
            <div class="input-group">
                <label>Target Format:</label>
                <select id="caseType" style="width:100%; padding:5px; background:var(--bg-row); color:var(--text-main); border:1px solid var(--border-color);">
                    <option value="upper">UPPERCASE</option>
                    <option value="lower">lowercase</option>
                    <option value="title">Title Case</option>
                    <option value="sentence">Sentence case</option>
                </select>
            </div>
            <div class="modal-actions">
                <button class="btn" style="background:transparent; border:1px solid var(--border-color); color:var(--text-main);" onclick="ViewModel.closeChangeCase()">Cancel</button>
                <button class="btn btn-save" style="width:auto;" onclick="ViewModel.executeChangeCase()">Apply</button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * STATE MANAGEMENT SECTION
 * Centralized store for all application data and UI states to ensure persistence.
 * 
 * FEATURE REGISTRY:
 * - Pane Management: Dynamic creation of Editor/Reference panes.
 * - File I/O: Read tab-delimited txt, Export modified txt.
 * - Tree Visualization: Hierarchical rendering based on Parent Key.
 * - CRUD: Update Key/Desc, Add Sibling, Delete Item.
 * - Drag & Drop: Re-parenting items via UI.
 * - Renumbering: Auto-sequence children keys.
 * - Audit: Visual comparison between panes.
 * - Search: Deep filtering of tree nodes.
 */
const AppState = {
    // 1. Data Store (The Content)
    // Structure: { [paneId]: Array<[Key, Description, ParentKey]> }
    panes: {}, 
    history: [], // Undo Stack
    paneMeta: {}, // { [paneId]: { filePath: String } }

    // 2. UI State (The Interface)
    ui: {
        primaryPaneId: null,     // ID of the main editing pane
        dirtyStatus: {},         // { [paneId]: boolean } - Tracks unsaved changes
        darkMode: localStorage.getItem('odi-dark-mode') !== 'false',
    },

    // 3. Interaction State (Transient)
    drag: {
        key: null,               // Key being dragged
        sourcePaneId: null       // Pane ID where drag started
    },
    
    recentFiles: JSON.parse(localStorage.getItem('odi-recent-files') || '[]'),

    // --- State Helpers ---
    registerPane(id, isPrimary = false) {
        this.panes[id] = null;
        this.paneMeta[id] = { filePath: null };
        this.ui.dirtyStatus[id] = false;
        if (isPrimary) this.ui.primaryPaneId = id;
    },

    setDirty(id, status = true) {
        this.ui.dirtyStatus[id] = status;
        const btn = document.getElementById(`save-${id}`);
        if (btn) btn.disabled = !status;
    },

    toggleDarkMode() {
        this.ui.darkMode = !this.ui.darkMode;
        document.documentElement.setAttribute('data-theme', this.ui.darkMode ? 'dark' : 'light');
        localStorage.setItem('odi-dark-mode', this.ui.darkMode);
    },

    initTheme() {
        if (this.ui.darkMode) document.documentElement.setAttribute('data-theme', 'dark');
    },

    addRecentFile(name, path, content) {
        // Remove existing if present to move to top
        this.recentFiles = this.recentFiles.filter(f => f.name !== name);
        // Add to front
        this.recentFiles.unshift({ name, path, content, date: new Date().toLocaleString() });
        // Limit to 5
        if (this.recentFiles.length > 5) this.recentFiles.pop();
        localStorage.setItem('odi-recent-files', JSON.stringify(this.recentFiles));
        this.updateRecentUI();
    },

    updateRecentUI() {
        Object.keys(this.panes).forEach(id => {
            const sel = document.getElementById(`recent-${id}`);
            if (sel) ViewModel.renderRecentList(sel);
        });
    },

    snapshot() {
        const state = {
            panes: JSON.parse(JSON.stringify(this.panes)),
            dirtyStatus: JSON.parse(JSON.stringify(this.ui.dirtyStatus))
        };
        this.history.push(state);
        if (this.history.length > 50) this.history.shift();
        this.updateUndoUI();
    },

    undo() {
        if (this.history.length === 0) return;
        const prevState = this.history.pop();
        this.panes = prevState.panes;
        this.ui.dirtyStatus = prevState.dirtyStatus;
        Object.keys(this.ui.dirtyStatus).forEach(id => this.setDirty(id, this.ui.dirtyStatus[id]));
        Object.keys(this.panes).forEach(id => ViewModel.render(id));
        this.updateUndoUI();
    },

    updateUndoUI() {
        const btn = document.getElementById('undoBtn');
        if (btn) {
            btn.disabled = this.history.length === 0;
            btn.style.opacity = this.history.length === 0 ? 0.5 : 1;
        }
    }
};

/**
 * VIEWMODEL: State & Interaction logic
 */
const ViewModel = {
    addPane(isPrimary = false) {
        const id = Date.now() + Math.floor(Math.random() * 100);
        AppState.registerPane(id, isPrimary);

        const paneHtml = `
            <div class="pane ${isPrimary ? 'primary' : 'secondary'}" id="pane-${id}">
                <div class="pane-header">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                        <span style="font-size:10px; opacity:0.7;">${isPrimary ? 'PRIMARY EDITOR' : 'REFERENCE'}</span>
                        <div style="display:flex; gap:5px;">
                            <span class="tool-btn" onclick="ViewModel.toggleAll(${id}, true)" title="Expand All">Expand All</span>
                            <span class="tool-btn" onclick="ViewModel.toggleAll(${id}, false)" title="Collapse All">Collapse All</span>
                            ${!isPrimary ? `<span class="tool-btn" style="color:#d32f2f" onclick="ViewModel.removePane(${id})" title="Close Pane">âœ•</span>` : ''}
                        </div>
                    </div>
                    <div class="file-info-box">
                        <span id="current-file-${id}" class="file-name">[No File Loaded]</span>
                        <span class="locate-btn" onclick="ViewModel.locateFile(${id})" title="Locate in Explorer">ðŸ“‚</span>
                    </div>
                    <input type="file" id="file-${id}" onchange="ViewModel.handleFileSelect(this, ${id})" style="display:block; width:100%;" title="Load a keynote .txt file">
                    <select id="recent-${id}" onchange="ViewModel.loadRecent(this, ${id})" style="display:block; width:100%; margin-top:5px; padding:4px; border:1px solid var(--border-color); background:var(--bg-panel); color:var(--text-main); border-radius:3px;" title="Load a recently opened file">
                        <option value="">Load Recent...</option>
                    </select>
                    <button id="save-${id}" class="btn btn-save" disabled onclick="ViewModel.exportFile(${id})" title="Save changes to a new .txt file">SAVE .TXT</button>
                </div>
                <div class="editor-layout">
                    ${isPrimary ? `
                        <div class="section-browser">
                            <div class="browser-header">
                                <span>DIVISIONS</span>
                                <div style="display:flex; gap:8px;">
                                    <span id="renum-btn" class="header-icon icon-red" onclick="ViewModel.renumber(${id})" title="Renumber Sequence">&#x21bb;</span>
                                    <span class="header-icon icon-blue" onclick="ViewModel.addDivision(${id})" title="Add Division">+</span>
                                </div>
                            </div>
                            <div id="browser-list-${id}"></div>
                        </div>` : ''}
                    <div class="keynote-scroll" id="s${id}"><div id="tree${id}"></div></div>
                </div>
            </div>`;

        const container = document.getElementById('paneBox');
        if (isPrimary) {
            const L = document.createElement('div'); L.className = 'resizer';
            const R = document.createElement('div'); R.className = 'resizer';
            container.appendChild(L); 
            container.insertAdjacentHTML('beforeend', paneHtml);
            container.appendChild(R);
            this.setupResizer(L, container.querySelector('.primary'), true);
            this.setupResizer(R, container.querySelector('.primary'), false);
        } else {
            container.insertAdjacentHTML('beforeend', paneHtml);
        }
        this.setupPaneDragDrop(id);
        this.renderRecentList(document.getElementById(`recent-${id}`));
        return id;
    },

    showToast(message) {
        const toast = document.getElementById('toast-notification');
        toast.innerText = message;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    },

    locateFile(id) {
        const meta = AppState.paneMeta[id];
        const path = (meta && meta.filePath) ? meta.filePath : document.getElementById(`current-file-${id}`).innerText;
        
        if (!path || path.includes("[No File Loaded]")) return;
        
        const isFullPath = path.includes('/') || path.includes('\\');
        
        navigator.clipboard.writeText(path).then(() => {
            this.showToast(isFullPath ? `Full Path copied: ${path}` : `Filename copied (Browser hides full path): ${path}`);
        }).catch(err => {
            console.error('Failed to copy filename: ', err);
            this.showToast('Error copying filename.');
        });
    },

    removePane(id) {
        if (id === AppState.ui.primaryPaneId) {
            alert("Cannot close the Primary Editor pane.");
            return;
        }
        const pane = document.getElementById(`pane-${id}`);
        if (pane) pane.remove();
        delete AppState.panes[id];
        delete AppState.paneMeta[id];
        delete AppState.ui.dirtyStatus[id];
        document.querySelectorAll('.row.audit-match').forEach(r => r.classList.remove('audit-match'));
        document.querySelectorAll('.row.selected-highlight').forEach(r => r.classList.remove('selected-highlight'));
        this.validateAuditState();
    },

    toggleAll(id, expand) {
        const tree = document.getElementById(`tree${id}`);
        if (!tree) return;
        const nodes = tree.querySelectorAll('.tree-node');
        nodes.forEach(node => {
            if (node.querySelector('.toggle')) {
                node.classList.toggle('collapsed', !expand);
            }
        });
    },

    renderRecentList(select) {
        if (!select) return;
        select.innerHTML = '<option value="">Load Recent...</option>';
        AppState.recentFiles.forEach((f, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.text = `${f.name} (${f.date})`;
            select.appendChild(opt);
        });
    },

    loadRecent(select, id) {
        const idx = select.value;
        if (idx === "") return;
        const fileData = AppState.recentFiles[idx];
        if (fileData) {
            AppState.panes[id] = fileData.content.split(/\r?\n/).map(l => l.split('\t')).filter(a => a.length >= 2);
            this.render(id);
            
            const path = fileData.path || fileData.name;
            AppState.paneMeta[id].filePath = path;
            this.updateFileInfo(id, fileData.name, path);
            
            this.validateAuditState();
            document.getElementById(`file-${id}`).value = ""; 
        }
        select.value = "";
    },

    handleFileSelect(input, id) { if (input.files[0]) this.processFile(input.files[0], id); },

    processFile(file, id) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            
            // Smart Path Resolution
            let path = file.path || file.name; // file.path works in some environments (Electron/NW.js), usually undefined in Chrome

            AppState.paneMeta[id].filePath = path;
            AppState.addRecentFile(file.name, path, content);
            AppState.panes[id] = content.split(/\r?\n/).map(l => l.split('\t')).filter(a => a.length >= 2);
            
            this.updateFileInfo(id, file.name, path);
            this.render(id);
            this.validateAuditState();
        };
        reader.readAsText(file);
    },

    updateFileInfo(id, name, path) {
        const el = document.getElementById(`current-file-${id}`);
        el.innerText = name;
        el.title = path; // Show full path on hover
    },

    render(id) {
        const container = document.getElementById(`tree${id}`);
        container.innerHTML = '';
        const data = AppState.panes[id];
        if (!data) return;

        const nodesMap = new Map();
        data.forEach(item => nodesMap.set(item[0].trim(), { key: item[0].trim(), desc: item[1].trim(), parent: (item[2] || "").trim(), children: [] }));
        const roots = [];
        nodesMap.forEach(node => {
            if (node.parent && nodesMap.has(node.parent)) nodesMap.get(node.parent).children.push(node);
            else roots.push(node);
        });

        // Sort nodes alphanumerically
        const sorter = (a, b) => a.key.localeCompare(b.key, undefined, { numeric: true, sensitivity: 'base' });
        roots.sort(sorter);
        nodesMap.forEach(n => n.children.sort(sorter));

        const buildNode = (node) => {
            const isRoot = !node.parent;
            const hasChildren = node.children.length > 0;
            const div = document.createElement('div'); div.className = 'tree-node';
            div.innerHTML = `
                <div class="row ${isRoot ? 'is-root' : ''}" data-key="${node.key}" draggable="true" onclick="ViewModel.syncScroll(${id}, '${node.key}')">
                    ${hasChildren ? '<span class="toggle" onclick="this.parentElement.parentElement.classList.toggle(\'collapsed\')">â–¼</span>' : '<span style="width:15px"></span>'}
                    <input class="key-num-input" value="${node.key}" onchange="ViewModel.updateData(${id}, '${node.key}', 0, this.value)">
                    <input class="key-desc-input" value="${node.desc}" onchange="ViewModel.updateData(${id}, '${node.key}', 1, this.value)">
                    <div class="action-tools">
                        <span class="tool-btn" onclick="ViewModel.addSibling(${id}, '${node.key}', '${node.parent}')" title="Add a new sibling keynote">+ Sib</span>
                        <span class="tool-btn" style="color:#d32f2f" onclick="ViewModel.deleteItem(${id}, '${node.key}')" title="Delete this keynote and all its children">âœ•</span>
                    </div>
                </div>
                <div class="lvl-container"></div>`;
            
            const row = div.querySelector('.row');
            this.setupRowDragDrop(row, id, node.key);

            const childBox = div.querySelector('.lvl-container');
            node.children.forEach(c => childBox.appendChild(buildNode(c)));
            return div;
        };
        roots.forEach(r => container.appendChild(buildNode(r)));
        if (id === AppState.ui.primaryPaneId) this.updateBrowser(id);
    },

    syncScroll(srcId, key) {
        document.querySelectorAll('.row.selected-highlight').forEach(r => r.classList.remove('selected-highlight'));

        // Get Source Description from Data Store
        const srcItem = AppState.panes[srcId]?.find(r => r[0].trim() === key);
        if (!srcItem) return;
        const targetDesc = srcItem[1].toLowerCase().trim();

        Object.keys(AppState.panes).forEach(pId => {
            const tree = document.getElementById(`tree${pId}`);
            if (!tree) return;

            // Find all data items in this pane that match the description
            const matches = AppState.panes[pId].filter(r => r[1].toLowerCase().trim() === targetDesc);
            
            let scrolledToPane = false;
            matches.forEach(m => {
                const matchKey = m[0].trim();
                const targetRow = tree.querySelector(`.row[data-key="${matchKey}"]`);
                
                if (targetRow) {
                    targetRow.classList.add('selected-highlight');
                    
                    // Expand parents to ensure visibility
                    let p = targetRow.closest('.tree-node').parentElement.closest('.tree-node');
                    while (p) {
                        p.classList.remove('collapsed');
                        p = p.parentElement.closest('.tree-node');
                    }

                    // Scroll to the first match in this pane
                    if (!scrolledToPane) {
                        targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        scrolledToPane = true;
                    }
                }
            });
        });
    },

    updateData(id, key, col, val) {
        AppState.snapshot();
        AppState.panes[id].forEach(r => {
            if (r[0].trim() === key) r[col] = val;
            if (col === 0 && r[2]?.trim() === key) r[2] = val;
        });
        AppState.setDirty(id, true);
    },

    validateAuditState() {
        const loaded = Object.keys(AppState.panes).filter(id => AppState.panes[id]).length;
        document.getElementById('auditBtn').disabled = (loaded < 2);
    },

    runAudit() {
        // Reset all rows first by removing the audit class
        document.querySelectorAll('.row').forEach(r => r.classList.remove('audit-match'));

        const ids = Object.keys(AppState.panes);
        ids.forEach(tId => {
            // Create a Set of descriptions from all other panes for efficient lookup
            const otherDescriptions = new Set(
                ids.filter(id => id != tId && AppState.panes[id])
                   .flatMap(id => AppState.panes[id].map(r => r[1].toLowerCase().trim()))
            );

            document.querySelectorAll(`#tree${tId} .row:not(.is-root)`).forEach(row => {
                const desc = row.querySelector('.key-desc-input').value.toLowerCase().trim();
                if (otherDescriptions.has(desc)) {
                    row.classList.add('audit-match');
                }
            });
        });
    },

    search(term) {
        const t = term.toLowerCase().trim();
        const allNodes = document.querySelectorAll('.tree-node');
        
        if (t === "") {
            allNodes.forEach(n => n.classList.remove('hidden'));
            return;
        }

        const visibleNodes = new Set();

        // 1. Find direct matches and collect all related nodes (ancestors and descendants)
        allNodes.forEach(node => {
            const row = node.querySelector('.row');
            const keyVal = row.querySelector('.key-num-input').value;
            const descVal = row.querySelector('.key-desc-input').value;
            
            if ((keyVal + " " + descVal).toLowerCase().includes(t)) {
                // A match is found, add it to the visible set
                visibleNodes.add(node);

                // 2. Add all its ancestors and expand them
                let p = node.parentElement.closest('.tree-node');
                while (p) {
                    visibleNodes.add(p);
                    p.classList.remove('collapsed');
                    p = p.parentElement.closest('.tree-node');
                }

                // 3. Add all its descendants
                node.querySelectorAll('.tree-node').forEach(descendant => {
                    visibleNodes.add(descendant);
                });
            }
        });

        // 4. Apply visibility based on the collected set
        allNodes.forEach(node => {
            node.classList.toggle('hidden', !visibleNodes.has(node));
        });
    },

    deleteItem(id, key) {
        if (!confirm(`Are you sure you want to delete '${key}'?\n(This will also delete all child items)`)) return;

        AppState.snapshot();
        const toDelete = new Set([key]);
        let foundNew = true;
        while (foundNew) {
            foundNew = false;
            AppState.panes[id].forEach(r => {
                const k = r[0].trim();
                const p = (r[2] || "").trim();
                if (toDelete.has(p) && !toDelete.has(k)) {
                    toDelete.add(k);
                    foundNew = true;
                }
            });
        }
        AppState.panes[id] = AppState.panes[id].filter(r => !toDelete.has(r[0].trim()));
        AppState.setDirty(id, true);
        this.render(id);
    },

    addDivision(id) {
        const key = prompt("Enter New Division Key (e.g. 'SHEET-NOTES'):");
        if (!key) return;
        if (this.checkKeyExists(id, key)) return alert("Key already exists!");
        
        const desc = prompt("Enter Description:", "New Division");
        if (desc === null) return;
        
        AppState.snapshot();
        AppState.panes[id].push([key, desc, ""]);
        AppState.setDirty(id, true);
        this.render(id);
    },

    addSibling(id, key, parent) {
        const suggested = this.suggestNextKey(id, parent);
        const newKey = prompt("Add Sibling - Enter Key Number:", suggested);
        if (newKey) {
            if (this.checkKeyExists(id, newKey)) return alert("Key already exists!");
            AppState.snapshot();
            AppState.panes[id].push([newKey, "New Sibling Item", parent]);
            AppState.setDirty(id, true); this.render(id);
        }
    },

    suggestNextKey(id, parentKey, excludeKey) {
        // Find all siblings, excluding the one being moved (to avoid self-reference in progression)
        const siblings = AppState.panes[id].filter(r => {
            const p = (r[2] || "").trim();
            const k = r[0].trim();
            return p === (parentKey || "").trim() && k !== excludeKey;
        });

        // Helper to parse key into segments (dot or space)
        const parseKey = (k) => k.split(/[\.\s]+/);
        const joinChar = (k) => k.includes('.') ? '.' : ' ';

        if (siblings.length === 0) {
            // Case: First Child - Try to adapt dragged key to new parent structure
            if (excludeKey && parentKey) {
                const pParts = parseKey(parentKey);
                const kParts = parseKey(excludeKey);
                const sep = joinChar(parentKey);
                
                // Scenario A: Deeper Level (e.g. Parent "10", Child "10.01")
                if (kParts.length > pParts.length) {
                    // Append the suffix from the dragged key to the new parent
                    const suffix = kParts.slice(pParts.length).join(sep);
                    if (suffix) return parentKey + sep + suffix;
                }
                
                // Scenario B: Same Level / Division Change (e.g. Parent "09 00 00", Dragged "08 10 00")
                // Intent: Become "09 10 00"
                if (kParts.length === pParts.length && kParts.length > 0) {
                    // Heuristic: If first segment differs (Division change), adopt new parent's division
                    if (pParts[0] !== kParts[0]) {
                        const newParts = [...kParts];
                        newParts[0] = pParts[0];
                        return newParts.join(sep);
                    }
                }
            }
            // Fallback default
            return parentKey ? (parentKey.includes(' ') ? `${parentKey} 01` : `${parentKey}.01`) : "01";
        }
        
        // Sort siblings to find the true last key (ensure numerical order)
        siblings.sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true, sensitivity: 'base' }));

        const lastKey = siblings[siblings.length - 1][0].trim();
        const match = lastKey.match(/(\d+)$/); // Find trailing number
        if (match) {
            const numStr = match[1];
            let step = 1;
            
            // Detect Step Size (e.g. 10, 20 -> 30)
            if (siblings.length >= 2) {
                const prevKey = siblings[siblings.length - 2][0].trim();
                const prevMatch = prevKey.match(/(\d+)$/);
                if (prevMatch) {
                    const diff = parseInt(numStr) - parseInt(prevMatch[1]);
                    if (diff > 0) step = diff;
                }
            }

            const nextNum = parseInt(numStr) + step;
            // Reassemble key preserving padding
            return lastKey.substring(0, match.index) + nextNum.toString().padStart(numStr.length, '0');
        }
        return lastKey + "_new";
    },

    checkKeyExists(id, key) {
        return AppState.panes[id].some(r => r[0].trim() === key);
    },

    updateKeyAndParent(id, oldKey, newKey, newParent) {
        // 1. Update the item itself
        const item = AppState.panes[id].find(r => r[0].trim() === oldKey);
        if (item) {
            item[0] = newKey;
            item[2] = newParent;
        }
        
        // 2. Recursive update for children (Parent Pointer AND Key Prefix)
        if (oldKey !== newKey) {
            const updateChildren = (pOld, pNew) => {
                AppState.panes[id].forEach(r => {
                    if ((r[2] || "").trim() === pOld) {
                        r[2] = pNew; // Update parent pointer
                        
                        // Update Key if it inherits prefix (Standard Hierarchy)
                        const k = r[0].trim();
                        if (k.startsWith(pOld)) {
                            const kNew = pNew + k.substring(pOld.length);
                            r[0] = kNew;
                            updateChildren(k, kNew); // Recurse
                        }
                    }
                });
            };
            updateChildren(oldKey, newKey);
        }
        AppState.setDirty(id, true); this.render(id);
    },

    renumber(id) {
        const selectedRow = document.querySelector(`#tree${id} .row.selected-highlight`);
        if (!selectedRow) {
            alert("Please select a parent section in the tree to renumber.");
            return;
        }
        const pk = selectedRow.getAttribute('data-key').trim();

        // CSI Check: Alert if it looks like MasterFormat (e.g. 03 10 00)
        if (/^\d{2}[\s\.]\d{2}/.test(pk)) {
            alert("Action Cancelled: CSI MasterFormat sections should not be auto-renumbered.");
            return;
        }

        if (!confirm(`Renumber all children of '${pk}'?\nThis will overwrite existing keys.`)) return;

        AppState.snapshot();
        const children = AppState.panes[id].filter(r => r[2]?.trim() === pk);
        if (children.length === 0) {
            alert("No children found for this parent key.");
            return;
        }

        // Determine Format Logic (Intuition)
        let format = "01";
        let sep = ".";
        
        const firstChildKey = children[0][0].trim();
        let suffix = firstChildKey;
        
        if (firstChildKey.startsWith(pk)) {
            const remainder = firstChildKey.substring(pk.length);
            const match = remainder.match(/^([\.\s]+)(.*)/);
            if (match) {
                sep = match[1];
                suffix = match[2];
            } else if (remainder.length > 0) {
                suffix = remainder;
                sep = "";
            }
        }

        if (/^\d+$/.test(suffix)) {
            if (suffix.length > 1 && suffix.startsWith('0')) format = "01";
            else format = "1";
        } else if (/^[A-Z]$/.test(suffix)) {
            format = "A";
        } else if (/^[A-Z]+\d+$/.test(suffix)) {
            const match = suffix.match(/^([A-Z]+)(\d+)$/);
            format = match[1] + (match[2].startsWith('0') && match[2].length > 1 ? "01" : "1");
        } else {
            const userFmt = prompt(`Detected mixed/unknown format (e.g. '${suffix}').\nEnter start sequence (e.g. '01', '1', 'A', 'A1'):`, "01");
            if (!userFmt) return;
            format = userFmt;
        }

        children.forEach((c, i) => {
            const old = c[0].trim();
            let newSuffix = "";
            const idx = i + 1;

            if (format === "01") {
                newSuffix = idx.toString().padStart(2, '0');
            } else if (format === "1") {
                newSuffix = idx.toString();
            } else if (format === "A") {
                const getAlpha = (n) => {
                    let s = "";
                    while (n > 0) {
                        let rem = (n - 1) % 26;
                        s = String.fromCharCode(65 + rem) + s;
                        n = Math.floor((n - 1) / 26);
                    }
                    return s;
                };
                newSuffix = getAlpha(idx);
            } else {
                const match = format.match(/^([A-Z]+)(\d+)$/);
                if (match) {
                    const pfx = match[1];
                    const numTemplate = match[2];
                    const isPadded = numTemplate.startsWith('0');
                    const len = Math.max(numTemplate.length, 2); 
                    newSuffix = pfx + (isPadded ? idx.toString().padStart(len, '0') : idx.toString());
                } else {
                    newSuffix = idx.toString().padStart(2, '0');
                }
            }

            const newK = `${pk}${sep}${newSuffix}`;
            if (old !== newK) {
                c[0] = newK;
                AppState.panes[id].forEach(r => { if(r[2]?.trim() === old) r[2] = newK; });
            }
        });
        AppState.setDirty(id, true); this.render(id);
    },

    // Helper to get the last logically ordered sibling key under a parent
    // This will be used to compare against the draggedKey
    getLastLogicalSiblingKey(paneId, parentKey, excludeKey = null) {
        const siblings = AppState.panes[paneId].filter(r => {
            const p = (r[2] || "").trim();
            const k = r[0].trim();
            return p === (parentKey || "").trim() && k !== excludeKey;
        });
        if (siblings.length === 0) return null;
        siblings.sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true, sensitivity: 'base' }));
        return siblings[siblings.length - 1][0].trim();
    },

    isKeyCompatibleWithParent(key, parentKey) {
        if (!parentKey) return true; // Root level, always compatible
        
        const k = key.trim();
        const p = parentKey.trim();

        // Direct child: key starts with parentKey.
        if (k.startsWith(p + ".") || k.startsWith(p + " ")) return true;

        // CSI / MasterFormat Logic (Significant Digits)
        // e.g. Parent "03 00 00" (Sig: 03) is compatible with "03 10 00"
        const getSig = (str) => {
            const parts = str.split(/[\.\s]+/);
            const sig = [];
            for (let part of parts) {
                if (parseInt(part) !== 0) sig.push(part);
                else break; 
            }
            return sig.join(str.includes('.') ? '.' : ' ');
        };
        
        const pSig = getSig(p);
        if (pSig && k.startsWith(pSig)) return true;

        return false;
    },
    copyChildren(srcId, targetId, srcParentKey, targetParentKey) {
        const children = AppState.panes[srcId].filter(r => (r[2] || "").trim() === srcParentKey);
        children.forEach(child => {
            const k = child[0].trim();
            // Try to map key prefix to maintain hierarchy logic
            let newK = k;
            if (k.startsWith(srcParentKey)) {
                newK = targetParentKey + k.substring(srcParentKey.length);
            } else {
                // Fallback logic if prefix doesn't match strictly
                newK = targetParentKey + "." + k.split('.').pop();
            }
            
            if (!this.checkKeyExists(targetId, newK)) {
                AppState.panes[targetId].push([newK, child[1], targetParentKey]);
            }
            this.copyChildren(srcId, targetId, k, newK);
        });
    },

    setupResizer(h, p, isL) {
        h.onmousedown = (e) => {
            const sW = p.offsetWidth; const sX = e.clientX;
            document.onmousemove = (me) => p.style.flex = `0 0 ${isL ? sW - (me.clientX - sX) : sW + (me.clientX - sX)}px`;
            document.onmouseup = () => document.onmousemove = null;
        };
    },

    setupPaneDragDrop(id) {
        const p = document.getElementById(`pane-${id}`);
        p.ondragover = (e) => e.preventDefault();
        p.ondrop = (e) => {
            e.preventDefault();
            if (e.dataTransfer.files.length > 0) {
                const f = e.dataTransfer.files[0];
                const dt = new DataTransfer(); dt.items.add(f);
                document.getElementById(`file-${id}`).files = dt.files;
                this.processFile(f, id);
            }
        };
    },

    setupRowDragDrop(row, id, key) {
        row.ondragstart = (e) => { AppState.drag.key = key; AppState.drag.sourcePaneId = id; e.stopPropagation(); };
        
        row.ondragover = (e) => { 
            e.preventDefault(); e.stopPropagation();
            
            // 1. Restrict Drop to Primary Pane Only (Modify Primary Only)
            if (String(id) !== String(AppState.ui.primaryPaneId)) {
                e.dataTransfer.dropEffect = 'none';
                return;
            }

            // Check for Merge Condition
            const srcId = AppState.drag.sourcePaneId;
            const draggedKey = AppState.drag.key;
            let isMergePrediction = false;

            if (srcId && String(srcId) !== String(id) && draggedKey) {
                 const existing = AppState.panes[id].find(r => r[0].trim() === draggedKey);
                 if (existing) {
                     const srcItem = AppState.panes[srcId].find(r => r[0].trim() === draggedKey);
                     if (srcItem && srcItem[1].trim().toLowerCase() === existing[1].trim().toLowerCase()) {
                         isMergePrediction = true;
                     }
                 }
            }

            const rect = row.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            const h = rect.height;
            
            // Clear classes
            row.classList.remove('drop-above', 'drop-below', 'drop-inside', 'drop-merge');
            
            if (isMergePrediction) {
                row.classList.add('drop-merge');
            } else {
                if (relY < h * 0.25) row.classList.add('drop-above');
                else if (relY > h * 0.75) row.classList.add('drop-below');
                else row.classList.add('drop-inside');
            }
        };

        row.ondragleave = () => row.classList.remove('drop-above', 'drop-below', 'drop-inside', 'drop-merge');
        
        row.ondrop = (e) => {
            e.preventDefault(); e.stopPropagation(); 
            
            // 1. Restrict Drop to Primary Pane Only
            if (String(id) !== String(AppState.ui.primaryPaneId)) return;

            const zone = row.classList.contains('drop-above') ? 'above' : 
                         row.classList.contains('drop-below') ? 'below' : 'inside';
            row.classList.remove('drop-above', 'drop-below', 'drop-inside', 'drop-merge');

            const srcId = AppState.drag.sourcePaneId;
            const draggedKey = AppState.drag.key;

            if (draggedKey && (String(srcId) === String(id) ? draggedKey !== key : true)) {
                // Determine New Parent based on Zone
                let newParent = "";
                if (zone === 'inside') newParent = key; // Become child
                else {
                    // Become sibling (Above/Below) -> Use target's parent
                    const targetItem = AppState.panes[id].find(r => r[0].trim() === key);
                    if (targetItem) newParent = (targetItem[2] || "").trim();
                }

                // Capture Scroll Position
                const scrollContainer = document.getElementById(`s${id}`);
                const savedScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;

                let finalKey = draggedKey;
                let proceed = true;

                // Check Duplicates (Only for Cross-Pane, as Internal Move preserves key)
                let isMerge = false;
                if (String(srcId) !== String(id)) {
                    const existing = AppState.panes[id].find(r => r[0].trim() === finalKey);
                    if (existing) {
                        const srcItem = AppState.panes[srcId].find(r => r[0].trim() === draggedKey);
                        if (srcItem && srcItem[1].trim().toLowerCase() === existing[1].trim().toLowerCase()) {
                            isMerge = true;
                            if (existing[1] !== srcItem[1]) {
                                existing[1] = srcItem[1]; // Update case/content
                                AppState.setDirty(id, true);
                            }
                        } else {
                            const suggested = this.suggestNextKey(id, newParent);
                            finalKey = prompt(`Key '${draggedKey}' already exists in target (Description mismatch).\nEnter new key:`, suggested);
                            if (!finalKey) proceed = false;
                            else if (this.checkKeyExists(id, finalKey)) {
                                alert("Key already exists!");
                                proceed = false;
                            }
                        }
                    }
                }

                if (proceed) {
                    AppState.snapshot();
                    if (String(srcId) === String(id)) {
                        // Internal Move
                        this.updateKeyAndParent(id, draggedKey, draggedKey, newParent);
                    } else {
                        // Cross-Pane Copy
                        const srcItem = AppState.panes[srcId].find(r => r[0].trim() === draggedKey);
                        if (srcItem) {
                            if (!isMerge) {
                                AppState.panes[id].push([finalKey, srcItem[1], newParent]);
                            }
                            
                            // Copy children
                            const hasChildren = AppState.panes[srcId].some(r => (r[2] || "").trim() === draggedKey);
                            if (hasChildren) {
                                this.copyChildren(srcId, id, draggedKey, finalKey);
                            }

                            AppState.setDirty(id, true); 
                            this.render(id);
                        }
                    }
                    
                    // Restore Scroll Position
                    if (scrollContainer) setTimeout(() => scrollContainer.scrollTop = savedScrollTop, 0);
                }
            }
        };
    },

    updateBrowser(id) {
        const list = document.getElementById(`browser-list-${id}`);
        list.innerHTML = '';
        AppState.panes[id].filter(r => !r[2] || r[2].trim() === "").forEach(div => {
            const el = document.createElement('div'); el.className = 'browser-item';
            el.innerText = div[0];
            el.onclick = () => {
                const target = document.querySelector(`#tree${id} .row[data-key="${div[0]}"]`);
                if(target) target.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };
            list.appendChild(el);
        });
    },

    exportFile(id) {
        const content = AppState.panes[id].map(r => r.join('\t')).join('\n');
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([content], {type:'text/plain'}));
        a.download = "Revised_Database.txt"; a.click();
        AppState.setDirty(id, false);
    },

    openFindReplace() {
        document.getElementById('findReplaceModal').classList.remove('hidden');
        document.getElementById('findInput').focus();
    },

    closeFindReplace() {
        document.getElementById('findReplaceModal').classList.add('hidden');
    },

    executeReplace() {
        const findText = document.getElementById('findInput').value;
        const replaceText = document.getElementById('replaceInput').value;
        const id = AppState.ui.primaryPaneId;

        if (!findText) { alert("Please enter text to find."); return; }
        if (!id || !AppState.panes[id]) return;

        AppState.snapshot();
        let count = 0;
        AppState.panes[id].forEach(r => {
            if (r[1].includes(findText)) {
                r[1] = r[1].split(findText).join(replaceText);
                count++;
            }
        });

        if (count > 0) {
            AppState.setDirty(id, true);
            this.render(id);
            alert(`Replaced ${count} occurrences.`);
            this.closeFindReplace();
        } else {
            AppState.history.pop(); AppState.updateUndoUI();
            alert('No matches found.');
        }
    },

    openChangeCase() {
        document.getElementById('changeCaseModal').classList.remove('hidden');
    },

    closeChangeCase() {
        document.getElementById('changeCaseModal').classList.add('hidden');
    },

    executeChangeCase() {
        const scope = document.getElementById('caseScope').value;
        const type = document.getElementById('caseType').value;
        const id = AppState.ui.primaryPaneId;
        
        if (!id || !AppState.panes[id]) return;

        let targetIndices = new Set();
        
        if (scope === 'selected') {
            const selectedRow = document.querySelector(`#tree${id} .row.selected-highlight`);
            if (!selectedRow) {
                alert("No section selected. Please select a row first or choose 'Entire File'.");
                return;
            }
            const rootKey = selectedRow.getAttribute('data-key').trim();
            
            // Build Parent Map for traversal
            const childrenMap = {};
            AppState.panes[id].forEach(r => {
                const p = (r[2] || "").trim();
                if (!childrenMap[p]) childrenMap[p] = [];
                childrenMap[p].push(r[0].trim());
            });

            const collectKeys = (k) => {
                let keys = [k];
                if (childrenMap[k]) childrenMap[k].forEach(childKey => keys = keys.concat(collectKeys(childKey)));
                return keys;
            };
            
            const keysToUpdate = new Set(collectKeys(rootKey));
            AppState.panes[id].forEach((r, idx) => { if (keysToUpdate.has(r[0].trim())) targetIndices.add(idx); });
        } else {
            AppState.panes[id].forEach((_, idx) => targetIndices.add(idx));
        }

        AppState.snapshot();
        let count = 0;
        targetIndices.forEach(idx => {
            const r = AppState.panes[id][idx];
            const oldText = r[1];
            let newText = oldText;
            
            if (type === 'upper') newText = oldText.toUpperCase();
            else if (type === 'lower') newText = oldText.toLowerCase();
            else if (type === 'title') newText = oldText.toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
            else if (type === 'sentence' && oldText.length > 0) newText = oldText.charAt(0).toUpperCase() + oldText.slice(1).toLowerCase();
            
            if (newText !== oldText) {
                r[1] = newText;
                count++;
            }
        });

        if (count > 0) {
            AppState.setDirty(id, true);
            this.render(id);
            alert(`Updated ${count} items.`);
            this.closeChangeCase();
        } else {
            AppState.history.pop(); AppState.updateUndoUI();
            alert('No changes needed.');
        }
    }
};

// --- Global Tooltip Logic ---
document.addEventListener('mouseover', (e) => {
    const target = e.target.closest('[title]');
    if (target) {
        const title = target.getAttribute('title');
        if (title) {
            target.setAttribute('data-title', title);
            target.removeAttribute('title');
            const tip = document.getElementById('tooltip');
            tip.innerText = title;
            tip.style.opacity = '1';
            tip.style.left = (e.clientX + 12) + 'px';
            tip.style.top = (e.clientY + 12) + 'px';
        }
    }
});
document.addEventListener('mouseout', (e) => {
    const target = e.target.closest('[data-title]');
    if (target) {
        target.setAttribute('title', target.getAttribute('data-title'));
        target.removeAttribute('data-title');
        document.getElementById('tooltip').style.opacity = '0';
    }
});
document.addEventListener('mousemove', (e) => {
    const tip = document.getElementById('tooltip');
    if (tip.style.opacity === '1') {
        tip.style.left = (e.clientX + 12) + 'px';
        tip.style.top = (e.clientY + 12) + 'px';
    }
});

ViewModel.addPane(true);
AppState.initTheme();
</script>
</body>
</html>